Q. Token-based authentication and session-based authentication

Q. Internal Structure of JWT

Q. JWT

Q. JWT Manipulation

Q. Authorization in Nest JS

Q. Token storage in frontend

---

### Token-based authentication and session-based authentication

Token-based authentication and session-based authentication are two different approaches to managing user authentication. Here's a comparison:
 
*Token-Based Authentication*
 
1. _Stateless_: Server doesn't store user session information.
2. _Tokens_: Client receives a token (e.g., JWT) after authentication.
3. _Token verification_: Server verifies token on each request.
4. _No session storage_: No server-side session storage required.
5. _Scalability_: Better scalability since no session storage needed.
6. _Security_: Tokens can be signed and encrypted for added security.
 
*Session-Based Authentication*
 
1. _Stateful_: Server stores user session information.
2. _Session ID_: Client receives a session ID after authentication.
3. _Session storage_: Server stores session data (e.g., user ID, permissions).
4. _Session verification_: Server verifies session ID on each request.
5. _Server-side storage_: Requires server-side session storage.
6. _Security_: Sessions can be vulnerable to attacks (e.g., session fixation).
 
Key differences:
 
- Token-based authentication is stateless, while session-based authentication is stateful.
- Token-based authentication uses tokens for verification, while session-based authentication uses session IDs.
- Token-based authentication is more scalable and secure, while session-based authentication can be more vulnerable to attacks.
 
When to use each:
 
- Token-based authentication:
    - API authentication
    - Mobile app authentication
    - Single-page applications (SPAs)
- Session-based authentication:
    - Traditional web applications
    - Applications requiring server-side session management
 
Remember, token-based authentication is generally more modern and secure, but session-based authentication can still be suitable for certain use cases.

---

### Internal Structure of JWT

The internal structure of a token typically consists of three parts:
 
1. ***Header***: Contains metadata about the token, such as:
    - Algorithm used for signing (e.g., HS256, RS256)
    - Token type (e.g., JWT, JWE)
2. ***Payload***: Contains the claims or data stored in the token, such as:
    - User identity (e.g., username, email)
    - Permissions or roles
    - Expiration time
    - Issuer and audience information
3. ***Signature***: A digital signature generated using the header, payload, and a secret key, ensuring token authenticity and integrity.
 
Here's a sample JWT token:
```
Header: {
  "alg": "HS256",
  "typ": "JWT"
}
Payload: {
  "sub": "1234567890",
  "name": "John Doe",
  "exp": 1643723400
}
Signature: "HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret_key
)"
```
The token is generated by:
 
1. Encoding the header and payload using Base64 URL-safe encoding.
2. Concatenating the encoded header and payload with a dot (`.`) separator.
3. Generating a digital signature using the concatenated string and a secret key.
4. Encoding the signature using Base64 URL-safe encoding.
 
The resulting token is a string consisting of three parts, separated by dots:
```
header.payload.signature
```
This token can be verified by decoding the header and payload, and re-generating the signature using the same secret key. If the signatures match, the token is valid.
has context menu

---

### JWT Overview

Here's a high-level overview of how JWT tokens work in Node.js:
 
*Step 1: User Authentication*
 
- User sends login request with credentials (e.g., username, password)
- Node.js server verifies credentials and authenticates user
 
*Step 2: Token Generation*
 
- Node.js server generates a JWT token using a secret key
- Token contains user data (e.g., user ID, name, email) and expiration time
- Token is signed with the secret key using an algorithm (e.g., HS256)
 
*Step 3: Token Return*
 
- Node.js server returns the JWT token to the client
- Client stores the token locally (e.g., in local storage or cookies)
 
*Step 4: Token Verification*
 
- Client sends the JWT token with each request to the Node.js server
- Node.js server verifies the token using the secret key and algorithm
- If token is valid, server grants access to protected resources
 
*Step 5: Token Expiration*
 
- Token expires after a specified time (e.g., 1 hour, 1 day)
- Client must request a new token by re-authenticating or using a refresh token
 
Node.js libraries like `jsonwebtoken` or `express-jwt` can be used to implement JWT token-based authentication.
 
Here's some sample Node.js code using `jsonwebtoken`:
```
const jwt = require('jsonwebtoken');
 
// Generate token
const token = jwt.sign({ userId: 1, name: 'John Doe' }, 'secretKey', { expiresIn: '1h' });
 
// Verify token
const decoded = jwt.verify(token, 'secretKey');
console.log(decoded); // { userId: 1, name: 'John Doe', iat: 1643723400, exp: 1643727000 }
```
Note: This is a simplified example and you should consider additional security measures like token blacklisting, refresh tokens, and secure key storage.

---

### refresh tokens

Refresh tokens are a crucial part of token-based authentication, especially when using JWT tokens. Here's a detailed explanation:
 
*What is a Refresh Token?*
 
A refresh token is a special token that allows a client to obtain a new access token (JWT token) without requiring the user to re-authenticate. It's essentially a "token to get a token."
 
*How does it work?*
 
1. *Initial Authentication*: The user authenticates with the server, and the server returns an access token (JWT token) and a refresh token.
2. *Access Token Expiration*: The access token expires after a specified time (e.g., 1 hour).
3. *Refresh Token Request*: The client sends the refresh token to the server to obtain a new access token.
4. *Server Verification*: The server verifies the refresh token and checks its validity.
5. *New Access Token*: If the refresh token is valid, the server generates a new access token and returns it to the client.
 
*Key characteristics of Refresh Tokens:*
 
1. *Long-lived*: Refresh tokens have a longer expiration time than access tokens (e.g., weeks, months).
2. *Secure storage*: Refresh tokens should be stored securely on the client-side (e.g., using secure storage like Keychain or Secure Enclave).
3. *Single-use*: Refresh tokens are typically used only once to obtain a new access token.
4. *Revocable*: Refresh tokens can be revoked by the server if compromised or expired.
 
*Benefits of Refresh Tokens:*
 
1. *Improved user experience*: Users don't need to re-authenticate every time the access token expires.
2. *Increased security*: Access tokens have a shorter lifespan, reducing the risk of token theft or compromise.
3. *Flexibility*: Refresh tokens can be used to implement token rotation, where access tokens are rotated regularly.
 
*Node.js example using jsonwebtoken*:
```
const jwt = require('jsonwebtoken');
 
// Generate refresh token
const refreshToken = jwt.sign({ userId: 1 }, 'refreshSecretKey', { expiresIn: '7d' });
 
// Generate access token
const accessToken = jwt.sign({ userId: 1 }, 'secretKey', { expiresIn: '1h' });
 
// Refresh token request
const newAccessToken = jwt.sign({ userId: 1 }, 'secretKey', { expiresIn: '1h' });
 
// Verify refresh token
jwt.verify(refreshToken, 'refreshSecretKey', (err, decoded) => {
  if (!err) {
    // Refresh token is valid, return new access token
    return newAccessToken;
  }
});
```
Note: This example uses a simplified refresh token implementation. In a real-world scenario, you should consider additional security measures like token blacklisting, secure key storage, and refresh token rotation.


**If the access token expires every 15 minutes, and the client uses the refresh token to obtain a new access token, then a new access token will be created every 15 minutes.**
 
Here's a summary of the flow:
 
1. Client authenticates with user credentials (e.g., username, password)
2. Server issues an access token (expires in 15 minutes) and a refresh token (long-lived)
3. Client uses the access token to access protected resources for 15 minutes
4. Access token expires
5. Client sends the refresh token to the server to obtain a new access token
6. Server verifies the refresh token and issues a new access token (expires in 15 minutes)
7. Client uses the new access token to access protected resources for another 15 minutes
8. Steps 4-7 repeat indefinitely
 
In this scenario, a new access token is created every 15 minutes, as long as the refresh token remains valid. This ensures that the client always has a valid access token to access protected resources, without requiring the user to re-authenticate.


**Here's an example of how you can implement access token and refresh token handling with middleware in Node.js using Express.js and JSON Web Tokens (JWT):**

```
const express = require('express');
const jwt = require('jsonwebtoken');
const app = express();

// Middleware to check for access token

const checkAccessToken = (req, res, next) => {

  const accessToken = req.headers['x-access-token'];
  if (!accessToken){
       return res.status(401).send('Access token is required');
  }

  jwt.verify(accessToken, process.env.SECRET_KEY, (err, decoded) => {
    if (err){
      return res.status(401).send('Invalid access token');
    }
    req.user = decoded;
    next();
  });
};


// Middleware to refresh access token

const refreshAccessToken = (req, res, next) => {

  const refreshToken = req.headers['x-refresh-token'];

  if (!refreshToken) {
      return res.status(401).send('Refresh token is required');
  }

  jwt.verify(refreshToken, process.env.SECRET_KEY, (err, decoded) => {

    if (err) {
      return res.status(401).send('Invalid refresh token');
    }

    const newAccessToken = jwt.sign({ userId: decoded.userId }, process.env.SECRET_KEY, { expiresIn: '15m' });

    res.set('x-access-token', newAccessToken);
    next();
  });
};

// Apply middleware

app.use(checkAccessToken);  
app.use(refreshAccessToken);

// Example route

app.get('/protected', (req, res) => {
  res.send(`Hello, ${req.user.userId}!`);
});

app.listen(3000, () => {
  console.log('Server listening on port 3000');
});

```

In this example:

- `checkAccessToken` middleware checks for the presence and validity of the access token.
- `refreshAccessToken` middleware checks for the presence and validity of the refresh token and generates a new access token if valid.
- Both middleware functions are applied to all routes using `app.use()`.
- The example route `/protected` is only accessible with a valid access token.

Note: This is a simplified example and you should consider additional security measures like token blacklisting, secure key storage, and refresh token rotation.

---
### JWT access tokens can be manipulated?

Yes, JWT access tokens can be manipulated, but it's important to note that JWTs are designed to be secure and tamper-proof. However, like any security mechanism, they are not foolproof.
 
Here are some ways JWT access tokens can be manipulated:
 
1. *Token tampering*: An attacker could try to modify the token's payload or signature. However, JWTs use digital signatures to prevent tampering. If a token is modified, the signature will be invalid, and the token will be rejected.
2. *Token forging*: An attacker could try to create a fake token with a valid signature. However, JWTs use a secret key to sign tokens, making it difficult for attackers to forge a valid token without the key.
3. *Token replay attacks*: An attacker could intercept a valid token and reuse it. To prevent this, JWTs can include a unique identifier (jti) and a limited lifetime (exp).
 
To minimize the risk of JWT manipulation:
 
1. *Use a secure secret key*: Keep your secret key safe and secure.
2. *Use a suitable algorithm*: Use a strong algorithm like HS256 or RS256.
3. *Validate tokens*: Always validate tokens on each request.
4. *Use token blacklisting*: Revoke and blacklist tokens when necessary.
5. *Use secure transmission*: Use HTTPS to transmit tokens securely.

---

### A token replay attack - 

A token replay attack occurs when an attacker intercepts a valid token and reuses it to gain unauthorized access to a system or resource. Here's an example:

***Scenario:***
1. Alice logs in to a web application and receives a valid JWT token:

```
{
  "sub": "Alice",
  "exp": 1643723400,
  "iat": 1643722800
}

```

1. The token is sent with each request to authenticate Alice.
2. An attacker, Bob, intercepts the token using a network sniffer or other means.
3. Bob reuses the token to send requests to the application, pretending to be Alice.

***Example:***

Suppose the application has an endpoint `/transfer-money` that requires authentication. Bob intercepts Alice's token and sends a request:

```
POST /transfer-money HTTP/1.1
Host: (link unavailable)
Authorization: Bearer <intercepted_token>

```
The application verifies the token and grants access, allowing Bob to transfer money as Alice.

***Consequences:***
Token replay attacks can lead to:

- Unauthorized access to sensitive data or actions
- Impersonation of legitimate users
- Security breaches

***Prevention:***
To prevent token replay attacks:

1. *Use HTTPS*: Encrypt tokens in transit to prevent interception.
2. *Token blacklisting*: Revoke and blacklist tokens when users log out or tokens expire.
3. *Token binding*: Bind tokens to specific devices or IP addresses.
4. *Short token lifetimes*: Use short token lifetimes to limit the window for replay attacks.
5. *Token validation*: Verify tokens on each request, checking for tampering, expiration, and blacklisting.

By implementing these measures, you can reduce the risk of token replay attacks and protect your application's security.

---

HTTPS (Hypertext Transfer Protocol Secure) encrypts tokens in transit using Transport Layer Security (TLS) or Secure Sockets Layer (SSL) encryption. Here's a simplified overview of the process:

1. _Client-Server Handshake_: When a client (e.g., web browser) connects to a server, they perform a TLS/SSL handshake to establish a secure connection.

2. _Certificate Verification_: The client verifies the server's identity by checking its digital certificate, which includes the server's public key.
3. _Symmetric Key Exchange_: The client and server negotiate a shared symmetric key, used for encrypting and decrypting data.
4. _Token Encryption_: When sending tokens, the client encrypts them using the shared symmetric key.
5. _Encrypted Token Transmission_: The encrypted token is transmitted over the secure connection.
6. _Server-Side Decryption_: The server decrypts the token using the shared symmetric key.

TLS/SSL encryption ensures that:

- Tokens are encrypted in transit, protecting against interception.
- Tokens are authenticated, ensuring they come from the expected client.
- Tokens are tamper-proof, preventing modification during transmission.

In more detail, HTTPS uses a combination of:

- *Symmetric encryption* (e.g., AES) for efficient encryption and decryption.
- *Asymmetric encryption* (e.g., RSA) for secure key exchange and authentication.
- *Digital certificates* to verify identities and establish trust.

By using HTTPS, you can ensure that tokens are encrypted and protected during transmission, reducing the risk of token interception and replay attacks.

---

### authorization in NestJS

In NestJS, authorization can be implemented using Guards, which are similar to middleware functions but provide more flexibility and power. Here's an example of how to implement authorization in NestJS:

1. *Create an Auth Guard*

Create a new file `auth.guard.ts`:

```
import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';
import { Reflector } from '@nestjs/core';

@Injectable()
export class AuthGuard implements CanActivate {
  constructor(private reflector: Reflector) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest();
    const roles = this.reflector.get<string[]>('roles', context.getHandler());

    if (!roles) {
      return true;
    }

    const user = request.user;

    if (!user || !user.roles) {
      return false;
    }
    return roles.some(role => user.roles.includes(role));
  }
}

```

This guard checks if the user has the required roles to access a route.

1. *Add Roles to Routes*
   
Add the `@Roles` decorator to your routes to specify the required roles:
```

import { Controller, Get, Post, Roles } from '@nestjs/common';

@Controller('users')
export class UsersController {

  @Get()
  @Roles('admin')
  async getAllUsers() {
    // ...
  }
  
  @Post()
  @Roles('user', 'admin')
  async createUser() {
    // ...
  }
}

```

In this example, the `getAllUsers` route requires the `admin` role, while the `createUser` route requires either the `user` or `admin` role.

1. *Apply the Auth Guard*

Apply the `AuthGuard` to your routes using the `@UseGuards` decorator:

```
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';\
import { UsersModule } from './users/users.module';
import { AuthGuard } from './auth.guard';

@Module({
  imports: [UsersModule],
  controllers: [AppController],
  providers: [AppService, AuthGuard],
})

export class AppModule {}

```

In this example, the `AuthGuard` is applied globally to all routes in the `AppModule`.

1. *Implement Authentication*

Implement authentication using a library like Passport.js or a custom solution. Once authenticated, attach the user object to the request using a middleware or a guard.

---

### Token storage in frontend

On the frontend side, tokens are typically stored in one of the following places:
 
1. *Local Storage*: A web storage mechanism that allows you to store data locally within the user's browser. Tokens can be stored in local storage using JavaScript.
2. *Session Storage*: Similar to local storage, but data is only stored for the duration of the session.
3. *Cookies*: Tokens can be stored in cookies, but this is less secure than local or session storage.
4. *Memory*: Some applications store tokens in memory, such as in a JavaScript variable, but this is less secure and not recommended.
5. *Secure Storage*: Some browsers provide a secure storage mechanism, like the Web Cryptography API, to store sensitive data like tokens.
 
When storing tokens on the frontend, consider the following:
 
- Use secure storage mechanisms like local storage or session storage.
- Use HTTPS to encrypt data in transit.
- Implement token expiration and renewal mechanisms.
- Handle token storage and retrieval securely in your application.
- Avoid storing sensitive data like tokens in cookies or memory.
 
Remember to always follow best practices for token storage and handling to ensure the security of your application.

